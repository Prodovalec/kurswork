modules-validators.h
#pragma once
#include <iostream>	
#include <Windows.h>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <regex>	
#include <conio.h>		
#include <iomanip>	

using namespace std;

int InputInt(); 
unsigned short InputMark();
string InputString();
string InputDate();

modules-validators.cpp
	#include "modules-validators.h"
int InputInt()
{
    int num;
    while (1) {
        cin >> num;
        if (cin.fail()) {
            cin.clear();
            cin.ignore(100, '\n');
            cout << "Некорректный ввод числа!\nПопробуйте ещё раз:";
            continue;
        }
        return num;
    }
}
unsigned short InputMark()
{
    short mark;
    while (1) {
        mark = InputInt();
        if (mark < 1) mark = 1;
        else if (mark > 5) mark = 5;
        return mark;
    }
}
string InputString()
{
    string str;
    getline(cin >> ws, str);
    return str;
}
string InputDate()
{
    regex reg("([0-2][0-9]|3[0-1]|[0-9]).(0[0-9]|1[0-2]|[0-9]).(199[3-9]|200[0-4])");
    
    string date = InputString();
    if (!regex_match(date, reg)) throw "Некорректно введена дата рождения!"; 
    return date;
}

	DATA.h

	#pragma once
#include "modules-validators.h"

struct Date {
	int day, month, year;

	void operator= (string date);
	
	string GetDate();
};
struct Session {
	void AddSubject(string sub, int mark);
	void DeleteSubject(string sub);
	map<string, int>& GetSubjects();
	string GetAllSub();
private:
	map<string, int> subjects;
};
class DATA
{
public:
	string name, surname, patronymic, faculty, department, group;
	bool sex;
	int admision_year, record_book;
	Date birth; 
	vector<Session> sessions;

	string DataToString();
};
	
	DATA.cpp

	#include "DATA.h"
void Date::operator=(string date)
{
	size_t dot = date.find(".");
	this->day = stoi(date.substr(0, dot));
	date.erase(0, dot+1);
	dot = date.find(".");
	this->month = stoi(date.substr(0, dot));
	date.erase(0, dot+1); 
	this->year = stoi(date.substr(0, 4));
}

string Date::GetDate() {
	return to_string(day) + "." + to_string(month) + "." + to_string(year);
} 
void Session::AddSubject(string sub, int mark)
{
	if (subjects.size() == 10) throw "Добавлено максимальное количество предметов!"; 
	subjects[sub] = mark; 
}

void Session::DeleteSubject(string sub)
{
	if(subjects.find(sub) == subjects.end()) throw "Такого предмета нет в сессии!";
	subjects.erase(sub); 
}

map<string, int>& Session::GetSubjects()
{
	return subjects;
}
string Session::GetAllSub() 
{
	string str("[ ");
	
	for (auto cur : subjects) {
		str += cur.first + " " + to_string(cur.second) + " ";
	}
	str += "]";
	return str;
}
string DATA::DataToString()
{
	string data;
	data = name + " " + surname + " " + patronymic + " " + birth.GetDate() + " " +to_string(admision_year) + " " + faculty + " " + department + " " + group + " " +to_string(record_book) + " " + (sex ? "муж" : "жен") + " ";
	for (auto cur : sessions) { 
		data += cur.GetAllSub() + " ";
	}

	return data; 
}
	
	NODE.h
	
	#pragma once
#include "DATA.h"
struct NODE 
{
	DATA data;
	NODE* next;
	NODE(); 
	NODE(DATA data, NODE* next = nullptr);
};
using ptrNODE = NODE*;
void init(ptrNODE& head);
bool empty(ptrNODE head); 
void add_by_pointer(ptrNODE& ptr, DATA data);
void add_head(ptrNODE& head, DATA data);
void add_after(ptrNODE& ptr, DATA data);
void delete_by_pointer(ptrNODE& ptr);
void del_from_head(ptrNODE& head);
void del_after(ptrNODE& ptr);
void clear(ptrNODE& head);
void print(ptrNODE head);
void sort_by_marks(ptrNODE& head);
void import(ifstream& fin, ptrNODE& head);
void fexport(ofstream& out, ptrNODE& head);
ptrNODE& find(ptrNODE& head);
void delete_student(ptrNODE& head);
void create_student(ptrNODE& head);
void edit_student(ptrNODE& head);
void ParceSession(string& str, vector<Session>& sess);

	NODE.cpp

	#include "NODE.h"
NODE::NODE()
{
	this->next = nullptr; 
}

NODE::NODE(DATA data, NODE* next)
{
	this->data = data; 
	this->next = next;
}

void init(ptrNODE& head)
{
	head = new NODE;
}

bool empty(ptrNODE head)
{
	return head->next == nullptr;
}

void add_by_pointer(ptrNODE& ptr, DATA data)
{
	ptrNODE p = new NODE(data, ptr);
	ptr = p;
}

void add_head(ptrNODE& head, DATA data)
{
	add_by_pointer(head, data);
}

void add_after(ptrNODE& ptr, DATA data)
{
	add_by_pointer(ptr->next, data);
}
void delete_by_pointer(ptrNODE& ptr)
{
	ptrNODE p = ptr;
	ptr = p->next;
	delete p;
}
void del_from_head(ptrNODE& head)
{
	delete_by_pointer(head);
}
void del_after(ptrNODE& ptr)
{
	delete_by_pointer(ptr->next);
}

void clear(ptrNODE& head)
{
	while (head)
		del_from_head(head);
}
void print(ptrNODE head)
{
	if (!head) {
		std::cout << "Список пуст!\n";
	}
	else
	{
		std::cout << "Выберите опцию:\n";
		std::cout << "1. Вывести студентов мужского пола\n";
		std::cout << "2. Вывести студентов женского пола\n";
		std::cout << "3. Вывести всех студентов\n";
		size_t choice = _getch() - '0';
		system("cls");

		std::cout << left << setw(12) << "Фамилия" << " | " << setw(10) << "Имя" << " | " << setw(15) << "Отчество" << " | ";
		std::cout << setw(13) << "Дата Рождения" << " | " << setw(15) << "Год поступления" << " | " << setw(10) << "Факультет";
		std::cout << " | " << setw(7) << "Кафедра" << " | " << setw(10) << "Группа" << " | " << setw(17) << "№ зачётной книжки" << " | " << setw(3) << "пол" << endl;
		ptrNODE p = head;
		while (p)
		{
			if (choice == 1 && p->data.sex == true) {
				std::cout << left << setw(12) << p->data.surname << " | " << setw(10) << p->data.name << " | " << setw(15) << p->data.patronymic << " | ";
				std::cout << setw(13) << p->data.birth.GetDate() << " | " << setw(15) << p->data.admision_year << " | " << setw(10) << p->data.faculty;
				std::cout << " | " << setw(7) << p->data.department << " | " << setw(10) << p->data.group << " | " << setw(17) << p->data.record_book << " | " << setw(3) << "муж" << endl;
				int c = 0;
				for (auto cur : p->data.sessions) {
					std::cout << ++c << "-й семестр\n";
					std::cout << cur.GetAllSub() << endl;
				}
				std::cout << '\n';
			}
			else if (choice == 2 && p->data.sex == false) {
				std::cout << left << setw(12) << p->data.surname << " | " << setw(10) << p->data.name << " | " << setw(15) << p->data.patronymic << " | ";
				std::cout << setw(13) << p->data.birth.GetDate() << " | " << setw(15) << p->data.admision_year << " | " << setw(10) << p->data.faculty;
				std::cout << " | " << setw(7) << p->data.department << " | " << setw(10) << p->data.group << " | " << setw(17) << p->data.record_book << " | " << setw(3) << "жен" << endl;
				int c = 0;
				for (auto cur : p->data.sessions) {
					std::cout << ++c << "-й семестр\n";
					std::cout << cur.GetAllSub() << endl;
				}
				std::cout << '\n';
			}
			else if (choice == 3) {
				std::cout << left << setw(12) << p->data.surname << " | " << setw(10) << p->data.name << " | " << setw(15) << p->data.patronymic << " | ";
				std::cout << setw(13) << p->data.birth.GetDate() << " | " << setw(15) << p->data.admision_year << " | " << setw(10) << p->data.faculty;
				std::cout << " | " << setw(7) << p->data.department << " | " << setw(10) << p->data.group << " | " << setw(17) << p->data.record_book << " | ";
				if (p->data.sex) {
					std::cout << setw(3) << "муж";
				}
				else {
					std::cout << setw(3) << "жен";
				}
				std::cout << endl;
				int c = 0;
				for (auto cur : p->data.sessions) {
					std::cout << ++c << "-й семестр\n";
					std::cout << cur.GetAllSub() << endl;
				}
				std::cout << '\n';
			}
			p = p->next;
		}
	}
} 
void sort_by_marks(ptrNODE& head)
{
	if (!head) {
		std::cout << "Список пуст!\n";
	}
	else
	{
		auto sort_condition = [](ptrNODE node) -> size_t {
			int count = 0;
			for (auto cur : node->data.sessions[0].GetSubjects()) {
				if (cur.second == 5) count++;
			}
			return count;
		};
		if (empty(head)) return;
		ptrNODE a, b, p, h = NULL;
		for (ptrNODE i = head; i != NULL; ) {
			a = i;
			i = i->next;
			b = h;
			for (p = NULL; (b != NULL) && (sort_condition(a) < sort_condition(b)); ) {
				p = b;
				b = b->next;
			}
			if (p == NULL) {
				a->next = h;
				h = a;
			}
			else {
				a->next = b;
				p->next = a;
			}
		}
		if (h != NULL)
			head = h;
	}
}
void import(ifstream& fin, ptrNODE& head)
{
	init(head);
	string line;
	ptrNODE tail = head;
	while (getline(fin, line))
	{
		DATA data;
		string delimiter = " ", token;
		size_t pos = 0, count = 0;
		while ((pos = line.find(delimiter)) != string::npos || pos + 1 != line.length())
		{
			token = line.substr(0, pos);
			switch (count)
			{
			case 0:
				data.surname = token;
				break;
			case 1:
				data.name = token;
				break;
			case 2:
				data.patronymic = token;
				break;
			case 3:
				data.birth = token;
				break;
			case 4:
				data.admision_year = stoi(token);
				break;
			case 5:
				data.faculty = token;
				break;
			case 6:
				data.department = token;
				break;
			case 7:
				data.group = token;
				break;
			case 8:
				data.record_book = stoi(token);
				break;
			case 9:
				data.sex = (token == "муж" ? true : false);
				break;
			default:
				break;
			}
			line.erase(0, pos + delimiter.length());
			count++;
			if (line[0] == '[')
			{
			ParceSession(line, data.sessions);
			}
		}
		add_after(tail, data);
		tail = tail->next;
	}
	del_from_head(head);
}
void fexport(ofstream& out, ptrNODE& head)
{
	ptrNODE temp = head;
	while (temp) {
		out << temp->data.DataToString() << "\n";
		temp = temp->next;
	}
}
void delete_student(ptrNODE& head) {
	std::cout << "Введите номер зачётной книжки: ";
	int book = InputInt();
	if (book == 0) return;
	if (to_string(book).length() != 7)
		throw "Некорректный ввод зачётной книжки!";
	ptrNODE temp = head;
	if (temp->data.record_book == book) {
		del_from_head(head);
		return;
	}
	while (temp->next) {
		if (temp->next->data.record_book == book) {
			del_after(temp);
			return;
		}
		temp = temp->next;
	}
	throw "В списке нет студента с таким номером зачётной книжки!";
}
void create_student(ptrNODE& head)
{
	DATA data;
	std::cout << "Фамилия: ";
	data.surname = InputString();
	std::cout << "Имя: ";
	data.name = InputString();
	std::cout << "Отчество: ";
	data.patronymic = InputString();
	std::cout << "Дата Рождения: ";
	data.birth = InputDate();
	std::cout << "Год поступления: ";
	data.admision_year = InputInt();
	if (data.admision_year > 2023 || data.admision_year < 2013)
		throw "Введён неправильный год!";
	std::cout << "Факультет: ";
	data.faculty = InputString();
	std::cout << "Кафедра: ";
	data.department = InputString();
	std::cout << "Группа: ";
	data.group = InputString();
	std::cout << "Номер зачётной книжки: ";
	data.record_book = InputInt();
	if (data.record_book / 1000 != data.admision_year && to_string(data.record_book).length() != 7)
		throw "Некорректный ввод зачётной книжки!";
	std::cout << "Пол: ";
	string sex_str = InputString();
	if (sex_str == "муж") {
		data.sex = 1;
	}
	else if (sex_str == "жен") {
		data.sex = 0;
	}
	else {
	}
	std::cout << "Введите количество семестров: ";
	int csess = InputInt();
	if (csess < 1 || csess > 10) throw "Некорректный ввод количества семестров!";
	for (size_t i = 0; i < csess; i++)
	{
		std::cout << i+1 << "-й Семестр\n";
		Session temp;
		try {
			while (1) {
				std::cout << "Введите название предмета: ";
				string subj = InputString();
				std::cout << "Введите оценку: ";
				int mark = InputMark();
				temp.AddSubject(subj, mark);
				std::cout << "Желаете продолжить? (Да\\Нет)";
				subj = InputString();
				if (subj == "Нет") break;
			}
		}
		catch (char* exp) {
			cerr << exp;
		}
		data.sessions.push_back(temp);
	}
	add_head(head, data);
}
void edit_student(ptrNODE& head) {
	ptrNODE temp = find(head);
	std::cout << "Что вы хотите изменить?\n";
	std::cout << "1. Фамилию\n2. Имя\n3. Отчество\n4. Дату Рождения\n5. Год поступления\n6. Факультет\n7. Кафедру\n8. Группу";
	std::cout << "\n9. Номер зачётной книжки\n10. Пол\n11. Информацию о сессии студента\n0. Выход\n";
	size_t choice = InputInt();
	switch (choice)
	{
	case 1:
		std::cout << "Введите новую фамилию: ";
		cin.ignore();
		temp->data.surname = InputString();
		break;
	case 2:
		std::cout << "Введите новое имя: ";
		cin.ignore();
		temp->data.name = InputString();
		break;
	case 3:
		std::cout << "Введите новое отчество: ";
		cin.ignore();
		temp->data.patronymic = InputString();
		break;
	case 4:
		std::cout << "Введите новую дату рождения: ";
		cin.ignore();
		temp->data.birth = InputDate();
		break;
	case 5:
		std::cout << "Введите новый год поступления: ";
		cin.ignore();
		temp->data.admision_year = InputInt();
		if (temp->data.admision_year > 2023 || temp->data.admision_year < 2013) throw "Введён неправильный год!";
		break;
	case 6:
		std::cout << "Введите новый факультет: ";
		cin.ignore();
		temp->data.faculty = InputString();
		break;
	case 7:
		std::cout << "Введите новую кафедру: ";
		cin.ignore();
		temp->data.department = InputString();
		break;
	case 8:
		std::cout << "Введите новую группу: ";
		cin.ignore();
		temp->data.group = InputString();
		break;
	case 9:
		std::cout << "Введите новый номер зачётной книжки: ";
		cin.ignore();
		temp->data.record_book = InputInt();
		if (temp->data.record_book / 1000 != temp->data.admision_year && to_string(temp->data.record_book).length() != 7)
			throw "Некорректный ввод зачётной книжки!";
		break;
	case 10:
		std::cout << "Введите новый пол (1 - муж, 0 - жен): ";
		cin.ignore();
		temp->data.sex = InputInt();
		break;
	case 11:
	{
		std::cout << "Введите номер семестра: ";
		int sem = InputInt();
		if (sem < 0 || sem > temp->data.sessions.size()) throw "Неправильный ввод номера семестра!";
		std::cout << "Введите название предмета: ";
		string subj = InputString();
		map<string, int> ::iterator it = temp->data.sessions[sem-1].GetSubjects().find(subj);
		if (it == temp->data.sessions[sem-1].GetSubjects().end()) {                           
			throw "Такого предмета нет в данной сессии!"; 
		}
		else {
			std::cout << "Изменение оценки по предмету " << it->first << " с " << it->second << " на: ";
			it->second = InputMark();
		}
	}
		break;
	default:
		std::cout << "Такого выбора не предусмотрено!";
		break;
	}
}
ptrNODE& find(ptrNODE& head)
{
	std::cout << "Введите номер зачётной книжки: ";
	int book = InputInt();
	if (to_string(book).length() != 7)
		throw "Некорректный ввод зачётной книжки!";
	ptrNODE temp = head;
	while (temp)
	{
		if (temp->data.record_book == book)
			return temp;
		temp = temp->next;
	}
	throw "В списке нет студента с таким номером зачётной книжки!";
}
void ParceSession(string& str, vector<Session>& sess)
{
	size_t csubj = 0, pos;
	while (str.size() > 0) {
		if (str[0] == '\r') {
			str.clear();
			break;
		}
		str.erase(0, 2);
		Session temp;
		while (((pos = str.find_first_of("12345")) != string::npos) && str[0] != '[') {
			temp.AddSubject(str.substr(0, pos - 1), str[pos] - '0');
			str[pos + 2] == ']' ? str.erase(0, pos + 4) : str.erase(0, pos + 2);
		}
		sess.push_back(temp);
	}
}

	CPanel.h

	#pragma once
#include "NODE.h"

void Menu(ptrNODE& head);

	CPanel.cpp
	
	#include "CPanel.h"
void Menu(ptrNODE& head)
{
	for (;;) {
		system("cls");
		cout << "-------------- Панель Управления --------------" << endl;
		cout << "1. Добавить студента" << endl;
		cout << "2. Удалить студента" << endl;
		cout << "3. Изменить информацию о студенте" << endl;
		cout << "4. Просмотр информации о студентах" << endl;
		cout << "5. Сортировка студентов по оценкам" << endl;
		cout << "0. Выход"<< endl;
		size_t choice = _getch() - '0';
		system("cls");
		try {
			switch (choice)
			{
			case 1:
				create_student(head);
				cout << "Студент был успешно добавлен в список!";
				Sleep(1500);
				break;
			case 2:
				delete_student(head);
				cout << "Данные о студенте были успешно удалены!";
				Sleep(1500);
				break;
			case 3:
				edit_student(head);
				cout << "Данные о студенте успешно изменены!";
				Sleep(1500);
				break;
			case 4:
				print(head);
				system("pause");
				break;
			case 5:
				sort_by_marks(head);
				cout << "Список студентов был успешно отсортирован!";
				Sleep(1500);
				break;
			case 0:
				return;
			default:
				cout << "Такого выбора не предусмотрено!";
				break;
			}
		}
		catch (const char* ex) {
			system("cls");
			cerr << ex;
			Sleep(2000);
		}
	}

}

	main.cpp

	#include "CPanel.h"
long nearestPowerOf2(long N)
{
	long a = log2(N);

	if (pow(2, a) == N)
		return N;

	return pow(2, a + 1);
}

void RSAKeyGen(long size) {
	long key_size = nearestPowerOf2(size);
	string prompt("openssl genrsa -out key.private ");
	prompt += to_string(key_size);
	system(prompt.c_str());
	prompt = "openssl rsa -in key.private -pubout -out key.public";
	system(prompt.c_str());
}

void RSAEncrypt(long size) {
	RSAKeyGen(size);
	string prompt("openssl pkeyutl -encrypt -pubin -inkey key.public -in file.bin -out file-enc.bin");
	system(prompt.c_str()); 
	system("del /f file.bin");
}

void RSADecrypt() {
	ifstream f("file.bin", ios_base::binary);
	if (f.good()) {
		f.close();
		return;
	}
	string prompt("openssl pkeyutl -decrypt -inkey key.private -in file-enc.bin -out file.bin");
	system(prompt.c_str());
	system("del /f file-enc.bin");
	system("del /f key.public");
	system("del /f key.private");
}
string AESKey() {
	cout << "Введите ключ: ";
	return InputString();
}

void AESEncrypt() {
	string prompt("openssl aes-256-cbc -salt -a -e -in file.bin -out file-enc.bin -pass pass:");
	prompt += AESKey();
	system(prompt.c_str());
	system("del /f file.bin"); 
}

void AESDecrypt() {
	ifstream f("file.bin", ios_base::binary);
	if (f) {
		f.close();
		return;
	}
	cout << "Дешифрование...\n";
	string prompt("openssl aes-256-cbc -salt -a -d -in file-enc.bin -out file.bin -pass pass:");
	prompt += AESKey();
	system(prompt.c_str()); 
}

int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	AESDecrypt();
	ifstream fin("file.bin", ios_base::binary); 
	if (!fin)
	{
		cout << "Файл не был найден!";
	}
	else {
		ptrNODE head;
		import(fin, head);
		Menu(head);
		fin.close();
		ofstream fout("file.bin", ios_base::binary);
		fexport(fout, head); 
		fout.close(); 
		clear(head); 
		cout << "Шифрование...\n";
		AESEncrypt(); 
		system("cls");
		cout << "Файл был успешно зашифрован!";
	}

	return 0;
}
